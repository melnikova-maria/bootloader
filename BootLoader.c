#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Pi/PiMultiPhase.h>
#include <Protocol/MpService.h>

void my_memcpy(void* destination, void* source, int size) {
  UINT8 *pdestination = (UINT8 *) destination;
  UINT8 *psource = (UINT8 *) source;
  if (size > 0) {
    for (int i = 0; i < size; ++i) {
      pdestination[i] = psource[i];
    }
  }
}

typedef struct _GDT {
  UINT16 segment_limit0_15;
  UINT16 base_address0_15;
  UINT8 base_address16_23;
  UINT8 flags_low;
  UINT8 flags_high;
  UINT8 base_address24_31;
} GDT;

typedef struct _GDTR {
  UINT16 length;
  GDT *gdt;
} GDTR;


EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE* SystemTable) {

  char main_jump[] = {
  0xe4, 0x92, 0x0c, 0x02, 0xe6, 0x92, 0x0f, 0x01, 0x16, 0x47, 0x80, 0xfa,
  0xe4, 0x70, 0x0c, 0x80, 0xe6, 0x70, 0x0f, 0x20, 0xc0, 0x0c, 0x01, 0x0f,
  0x22, 0xc0, 0xea, 0x4d, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x9a, 0xcf, 0x00, 0xff,
  0xff, 0x00, 0x00, 0x00, 0x92, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x9a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x20, 0x00, 0x28,
  0x00, 0x1f, 0x80, 0x00, 0x00, 0x66, 0xb8, 0x10, 0x00, 0x8e, 0xd8, 0x8e,
  0xc0, 0x0f, 0x20, 0xe0, 0x0f, 0xba, 0xe8, 0x05, 0x0f, 0x22, 0xe0, 0xbf,
  0x00, 0x00, 0x10, 0x00, 0xb9, 0x00, 0x00, 0x0c, 0x00, 0x31, 0xc0, 0x26,
  0x89, 0x07, 0x83, 0xc7, 0x08, 0xe2, 0xf8, 0xc7, 0x05, 0x00, 0x00, 0x10,
  0x00, 0x07, 0x00, 0x11, 0x00, 0xc7, 0x05, 0x00, 0x00, 0x11, 0x00, 0x07,
  0x00, 0x12, 0x00, 0xc7, 0x05, 0x08, 0x00, 0x11, 0x00, 0x07, 0x10, 0x12,
  0x00, 0xc7, 0x05, 0x10, 0x00, 0x11, 0x00, 0x07, 0x20, 0x12, 0x00, 0xc7,
  0x05, 0x18, 0x00, 0x11, 0x00, 0x07, 0x30, 0x12, 0x00, 0xbf, 0x00, 0x00,
  0x12, 0x00, 0xb8, 0x87, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x08, 0x00, 0x00,
  0x26, 0x89, 0x07, 0x83, 0xc7, 0x08, 0x05, 0x00, 0x00, 0x20, 0x00, 0xe2,
  0xf3, 0xb8, 0x00, 0x00, 0x10, 0x00, 0x0f, 0x22, 0xd8, 0xb9, 0x80, 0x00,
  0x00, 0xc0, 0x0f, 0x32, 0x0f, 0xba, 0xe8, 0x08, 0x0f, 0x30, 0x0f, 0x20,
  0xc0, 0x0f, 0xba, 0xe8, 0x1f, 0x0f, 0x22, 0xc0, 0xea, 0xe7, 0x80, 0x00,
  0x00, 0x18, 0x00, 0x66, 0xb8, 0x20, 0x00, 0x8e, 0xd8, 0x8e, 0xc0, 0x0f,
  0x01, 0x14, 0x25, 0x00, 0x94, 0x00, 0x00, 0x48, 0x8b, 0x04, 0x25, 0x08,
  0x03, 0x00, 0x00, 0x48, 0xff, 0xc0, 0x48, 0x89, 0x04, 0x25, 0x08, 0x03,
  0x00, 0x00, 0x48, 0x8b, 0x04, 0x25, 0x14, 0x81, 0x00, 0x00, 0xff, 0xe0,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00};

  char c_code[] = {
  0xbc, 0x00, 0x00, 0x01, 0x00, 0x48, 0x89, 0xe5, 0xe8, 0x13, 0x00, 0x00,
  0x00, 0xeb, 0xfe, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x0f, 0x1e, 0xfa,
  0x48, 0x8b, 0x05, 0xe5, 0xff, 0xff, 0xff, 0x48, 0x89, 0x05, 0xe6, 0xff,
  0xff, 0xff, 0x48, 0x8b, 0x15, 0xdf, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x02,
  0x48, 0xff, 0xc0, 0x48, 0x89, 0x02, 0x48, 0x8b, 0x04, 0x25, 0x00, 0x03,
  0x00, 0x00, 0x48, 0xff, 0xc0, 0x48, 0x89, 0x04, 0x25, 0x00, 0x03, 0x00,
  0x00, 0xeb, 0xdb}; // inc [0x300]

  char ap_jump[] = {
  0xe4, 0x92, 0x0c, 0x02, 0xe6, 0x92, 0x0f, 0x01, 0x16, 0x47, 0x84, 0xfa,
  0xe4, 0x70, 0x0c, 0x80, 0xe6, 0x70, 0x0f, 0x20, 0xc0, 0x0c, 0x01, 0x0f,
  0x22, 0xc0, 0xea, 0x4d, 0x84, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x9a, 0xcf, 0x00, 0xff,
  0xff, 0x00, 0x00, 0x00, 0x92, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x9a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x20, 0x00, 0x28,
  0x00, 0x1f, 0x84, 0x00, 0x00, 0x66, 0xb8, 0x10, 0x00, 0x8e, 0xd8, 0x8e,
  0xc0, 0x0f, 0x20, 0xe0, 0x0f, 0xba, 0xe8, 0x05, 0x0f, 0x22, 0xe0, 0xbf,
  0x00, 0x00, 0x10, 0x00, 0xb9, 0x00, 0x00, 0x0c, 0x00, 0x31, 0xc0, 0x26,
  0x89, 0x07, 0x83, 0xc7, 0x08, 0xe2, 0xf8, 0xc7, 0x05, 0x00, 0x00, 0x10,
  0x00, 0x07, 0x00, 0x11, 0x00, 0xc7, 0x05, 0x00, 0x00, 0x11, 0x00, 0x07,
  0x00, 0x12, 0x00, 0xc7, 0x05, 0x08, 0x00, 0x11, 0x00, 0x07, 0x10, 0x12,
  0x00, 0xc7, 0x05, 0x10, 0x00, 0x11, 0x00, 0x07, 0x20, 0x12, 0x00, 0xc7,
  0x05, 0x18, 0x00, 0x11, 0x00, 0x07, 0x30, 0x12, 0x00, 0xbf, 0x00, 0x00,
  0x12, 0x00, 0xb8, 0x87, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x08, 0x00, 0x00,
  0x26, 0x89, 0x07, 0x83, 0xc7, 0x08, 0x05, 0x00, 0x00, 0x20, 0x00, 0xe2,
  0xf3, 0xb8, 0x00, 0x00, 0x10, 0x00, 0x0f, 0x22, 0xd8, 0xb9, 0x80, 0x00,
  0x00, 0xc0, 0x0f, 0x32, 0x0f, 0xba, 0xe8, 0x08, 0x0f, 0x30, 0x0f, 0x20,
  0xc0, 0x0f, 0xba, 0xe8, 0x1f, 0x0f, 0x22, 0xc0, 0xea, 0xe7, 0x84, 0x00,
  0x00, 0x18, 0x00, 0x66, 0xb8, 0x20, 0x00, 0x8e, 0xd8, 0x8e, 0xc0, 0x0f,
  0x01, 0x14, 0x25, 0x00, 0x94, 0x00, 0x00, 0x48, 0x8b, 0x04, 0x25, 0x08,
  0x03, 0x00, 0x00, 0x48, 0xff, 0xc0, 0x48, 0x89, 0x04, 0x25, 0x08, 0x03,
  0x00, 0x00, 0xeb, 0xfe};

  GDT boot_gdt[] = {
    {0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00}, // NULL descriptor
    {0xFFFF, 0x0000, 0x00, 0x9A, 0xCF, 0x00}, // CODE32 descriptor
    {0xFFFF, 0x0000, 0x00, 0x92, 0xCF, 0x00}, // DATA32 descriptor
    {0x0000, 0x0000, 0x00, 0x9A, 0x20, 0x00}, // CODE64 descriptor
    {0x0000, 0x0000, 0x00, 0x92, 0x20, 0x00}  // DATA64 descriptor
  };
  GDTR gdtr = {5*8 - 1, (GDT *) 0x9400};
  
  UINT32 init_code_entry1 = 0x8000;
  UINT32 init_code_entry2 = 0x9000;

  my_memcpy((void *) 0x8000, (void *) main_jump, 284);  // прыжок в long Mode с переходом на си-код для bsp-процессора
  my_memcpy((void *) 0x9000, (void *) ap_jump, 268);    // прыжок в long Mode для ap-процессора (код зацикливается в long Mode)
  my_memcpy((void *) 0x10000, (void *) c_code, 87);     // си-код
  my_memcpy((void *) 0x9400, (void *) boot_gdt, 48);    // "постоянную" таблицу GDT размещаем по адресу 0x9400
  my_memcpy((void *) 0x9500, (void *) &gdtr, 80);       // структура, соответствующая регистру GDTR, размещена по адресу 0x9500

  EFI_STATUS status;
  EFI_MP_SERVICES_PROTOCOL *mp = NULL;
  UINTN number_of_proc;
  UINTN number_of_enabled_proc;
  EFI_PROCESSOR_INFORMATION processor_info;

  status = SystemTable -> BootServices -> LocateProtocol(&gEfiMpServiceProtocolGuid, NULL, (void **) &mp);
  if (EFI_ERROR (status)) {
    Print(L"Unable to initialize MP protocol interface!");
    return EFI_UNSUPPORTED;
  }
  
  status = mp -> GetNumberOfProcessors(mp, &number_of_proc, &number_of_enabled_proc);
  
  if (EFI_ERROR(status)) {
    Print( L"Error\nGetNumberProcessors: Unable to determine number of processors\n");
    return EFI_UNSUPPORTED;
  } 

  Print(L"Number of Processors = %d\n", number_of_proc);
  Print(L"Number of Enabled Processors = %d\n", number_of_enabled_proc);
  for (UINTN i = 0; i < number_of_proc; i++) {
    status = mp -> GetProcessorInfo(mp, i, &processor_info);
    
    Print( L"Processor #%d ACPI Processor ID = %lX, Flags = %x, Package = %x, Core = %x, Thread = %x \n", 
          i,
          processor_info.ProcessorId, 
          processor_info.StatusFlag,
          processor_info.Location.Package,
          processor_info.Location.Core,
          processor_info.Location.Thread);
  }

// запуск процессора ID = 1
  status = mp -> GetProcessorInfo(mp, 1, &processor_info);
  int ap_apic_id = processor_info.ProcessorId;

  UINT32 * const APIC_ICR_LOW = (void *) 0xFEE00300;
  UINT32 * const APIC_ICR_HIG = (void *) 0xFEE00310;

  // INIT
  *APIC_ICR_HIG = (UINT32) ap_apic_id << 24;
  *APIC_ICR_LOW = 0x00000500;

  for (volatile UINTN i = 0; i < 0xFFFFFFF; ++i);

  // SIPI
  *APIC_ICR_LOW = ((UINT32) 0x00000600 | (init_code_entry1 >> 12));

  Print(L"Sending SIPI to ProcessorID = #%d\n", ap_apic_id);
  
// запуск процессоров ID = 2, 3
  for (UINTN i = 2; i < number_of_proc; ++i) {
    status = mp -> GetProcessorInfo(mp, i, &processor_info);
    ap_apic_id = processor_info.ProcessorId;

    UINT32 * const APIC_ICR_LOW = (void *) 0xFEE00300;
    UINT32 * const APIC_ICR_HIG = (void *) 0xFEE00310;

    // INIT
    *APIC_ICR_HIG = (UINT32) ap_apic_id << 24;
    *APIC_ICR_LOW = 0x00000500;

    for (volatile UINTN i = 0; i < 0xFFFFFFF; ++i);

    // SIPI
    *APIC_ICR_LOW = ((UINT32) 0x00000600 | (init_code_entry2 >> 12));

    Print(L"Sending SIPI to ProcessorID = #%d\n", ap_apic_id);
    SystemTable -> BootServices -> Stall(5000000);
  }
  return EFI_SUCCESS;
}
